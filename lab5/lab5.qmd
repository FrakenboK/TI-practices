---
title: "Практическая работа №5. Исследование информации о состоянии беспроводных сетей"
author: "kobyakmihail@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы

1. Получить знания о методах исследования радиоэлектронной обстановки.
2. Составить представление о механизмах работы Wi-Fi сетей на канальном и сетевом уровне модели OSI.
3. Зекрепить практические навыки использования языка программирования R для обработки данных
4. Закрепить знания основных функций обработки данных экосистемы `tidyverse` языка R

## Исходные данные

1.  Программное обеспечение Windows 11
2.  Интерпретатор языка R v4.5.1
3.  Rstudio IDE

## Общая ситуация

Вы исследуете состояние радиоэлектронной обстановки с помощью журналов программных средств анализа беспроводных сетей – `tcpdump` и `airodump-ng`. Для этого с помощью сниффера (микрокомпьютера Raspberry Pi и специализированного Wi-Fi адаптера, переведенного в режим мониторинга) собирались данные. Сниффер беспроводного трафика был установлен стационарно (не перемещался). Какой анализ можно провести с помощью собранной информации

## Задание

Используя программный пакет `dplyr` языка программирования R провести анализ журналов и ответить на вопросы

## Подготовка к выполнению задания 

Произведем загрузку библиотек:

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(readr)

library(httr)

library(dplyr)
```

## Шаги

### Подготовка данных

#### 1. Импортируйте данные

Для начала скачаем данные:

```{r}
if (!dir.exists("data")) {
    dir.create("data")
}

wifi_csv_url <- "https://storage.yandexcloud.net/dataset.ctfsec/P2_wifi_data.csv"
csv_filename <- "data/P2_wifi_data.csv"

download.file(
    url = wifi_csv_url,
    destfile = csv_filename,
    mode = "wb",
    quiet = FALSE
)
```

Прочитаем данные двух датасетов из CSV-файла: 

```{r}
file_content <- read_lines(csv_filename)
second_table_start <- which(grepl("Station MAC", file_content))

wifi_data <- read_csv(
    csv_filename, 
    n_max = second_table_start[1] - 4
)

head(wifi_data)

client_conn_data <- read_csv(
    csv_filename, 
    skip = second_table_start[1] - 2
)

head(client_conn_data)
```

#### 2. Привести датасеты в вид "аккуратных данных", преобразовать типы столбцов всоответствии с типом данных

Преобразуем данные

```{r}
wifi_data <- wifi_data %>%

    rename_with(~ gsub("[.# ]", "_", .x)) %>%
    rename_with(~ gsub("_+", "_", .x)) %>%
    rename_with(~ tolower(.x))%>%
    rename_with(~ gsub("^_+", "", .x))%>%
    rename_with(~ gsub("-", "_", .x))%>%


    mutate(
        channel = as.integer(channel),
        speed = as.integer(speed),
        power = as.integer(power),
        beacons = as.integer(beacons),
        iv = as.integer(iv),
        id_length = as.integer(id_length),
        privacy = as.factor(privacy),
        cipher = as.factor(cipher),
        authentication = as.factor(authentication),
    )

client_conn_data <- client_conn_data %>%

    rename_with(~ gsub("[.# ]", "_", .x)) %>%
    rename_with(~ gsub("_+", "_", .x)) %>%
    rename_with(~ tolower(.x))%>%
    rename_with(~ gsub("^_+", "", .x))%>%
    rename_with(~ gsub("-", "_", .x))%>%

    mutate(
        power = as.integer(power),
        packets = as.integer(packets),
        
    )
```

#### 3. Просмотрите общую структуру данных с помощью функции `glimpse`

```{r}
glimpse(wifi_data)

glimpse(client_conn_data)
```

### Анализ точек доступа

#### 1. Определить небезопасные точки доступа (без шифрования – OPN)

```{r}
wifi_data %>%
    filter(privacy == "OPN")
```

#### 2. Определить производителя для каждого обнаруженного устройства

Для этого воспользуемся запросами в API, а также настроим кэш, для уменьшения количества сетевых запросов

```{r}
manufacturer_cache <- new.env(hash = TRUE)

get_manufacturer <- function(mac_address) {
    clean_mac <- gsub("[:.-]", "", mac_address)
    clean_mac <- toupper(clean_mac)
    
    oui <- substr(clean_mac, 1, 6)
    
    if (exists(oui, envir = manufacturer_cache)) {
        return(get(oui, envir = manufacturer_cache))
    }
    
    url <- paste0("https://www.macvendorlookup.com/api/v2/", oui)
    response <- GET(url, timeout(3))
    
    if (status_code(response) == 200) {
        content_data <- content(response, "parsed")
        
        if (length(content_data) > 0) {
            manufacturer <- content_data[[1]]$company
            if (is.null(manufacturer) || manufacturer == "") {
                manufacturer <- "Unknown"
            }
        } else {
            manufacturer <- "Unknown"
        }
        
        assign(oui, manufacturer, envir = manufacturer_cache)
        return(manufacturer)
        
    } else {
        assign(oui, "Unknown", envir = manufacturer_cache)
        return("Unknown")
    }
}

wifi_data <- wifi_data %>%
mutate(
    manufacturer = sapply(bssid, get_manufacturer)
)

wifi_data %>% select(bssid, manufacturer)
```

#### 3. Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах

```{r}
wifi_data %>%
    filter(str_detect(privacy, "WPA3")) %>%
    arrange(desc(power))
```

#### 4. Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию (Не забудьте склеить сессии! Сессии считаются независимыми если интервал времени между ними превышает 45 минут.)

Для этого реализуем функцию склейки:

```{r}
merge_sessions <- function(data, max_gap_minutes = 45) {
  
    data_prepared <- data %>%
        mutate(
        first_time_seen = as.POSIXct(first_time_seen),
        last_time_seen = as.POSIXct(last_time_seen)
        ) %>%
        arrange(bssid, first_time_seen)
    
    merge_group_sessions <- function(group_data) {
        if (nrow(group_data) == 1) {
            return(group_data %>%
                    mutate(
                        session_id = 1,
                        session_duration_minutes = as.numeric(
                        difftime(last_time_seen, first_time_seen, units = "mins")
                        )
                    )
            )
        }
    
        result <- group_data %>%
            arrange(first_time_seen) %>%
            mutate(
                prev_last_time = lag(last_time_seen),
                gap_minutes = ifelse(
                    is.na(prev_last_time),
                    0,
                    as.numeric(difftime(first_time_seen, prev_last_time, units = "mins"))
                ),
                session_start = ifelse(row_number() == 1 | gap_minutes > max_gap_minutes, 
                                    TRUE, FALSE),
                session_id = cumsum(session_start)
            ) %>%
            group_by(session_id) %>%
            summarise(
                merged_first_time_seen = min(first_time_seen),
                merged_last_time_seen = max(last_time_seen),
                essid = first(essid),
                channel = first(channel),
                privacy = first(privacy),
                manufacturer = first(manufacturer),
                avg_power = mean(power, na.rm = TRUE),
                max_power = max(power, na.rm = TRUE),
                total_beacons = sum(beacons, na.rm = TRUE),
                total_iv = sum(iv, na.rm = TRUE),
                num_sessions_merged = n(),
                .groups = "drop"
            ) %>%
            mutate(
                session_duration_minutes = as.numeric(
                    difftime(merged_last_time_seen, merged_first_time_seen, units = "mins")
                )
            )
        
        return(result)
    }
  
    wifi_sessions <- data_prepared %>%
        group_by(bssid) %>%
        group_modify(~ merge_group_sessions(.x)) %>%
        ungroup() %>%
        mutate(
        session_duration_hours = round(session_duration_minutes / 60, 2),
        session_duration_days = round(session_duration_minutes / (60 * 24), 2)
        ) %>%
        arrange(desc(session_duration_minutes))
    
    return(wifi_sessions)
}

merge_sessions(wifi_data)
```

#### 5. Обнаружить топ-10 самых быстрых точек доступа

```{r}
wifi_data %>%
    filter(!is.na(speed) & speed > 0) %>%
    arrange(desc(speed)) %>%
    head(10)
```

#### 6. Отсортировать точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию

```{r}
wifi_data %>%
    filter(!is.na(beacons) & beacons > 0 & 
            !is.na(first_time_seen) & !is.na(last_time_seen)) %>%

    mutate(
        first_time_seen = as.POSIXct(first_time_seen),
        last_time_seen = as.POSIXct(last_time_seen),
        duration_minutes = as.numeric(difftime(last_time_seen, first_time_seen, units = "mins")),
        duration_minutes = ifelse(duration_minutes <= 0, 0.1, duration_minutes),
        beacon_rate_per_min = beacons / duration_minutes,
        beacon_rate_per_sec = beacon_rate_per_min / 60,
        beacon_rate_per_hour = beacons / (duration_minutes / 60)
    ) %>%

    arrange(desc(beacon_rate_per_min)) 
```

### Анализ клиентов

#### 1. Определить производителя для каждого обнаруженного устройства

Для этого воспользуемся функцией, написанной нами для поиска производителей точек доступа:

```{r}
client_conn_data <- client_conn_data %>%
    filter(!is.na(bssid) & bssid != "(not associated)") %>%
    mutate(
        manufacturer = sapply(bssid, get_manufacturer)
    )

client_conn_data %>% select(bssid, manufacturer)
```

#### 2. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес

```{r}
rand_prefixes <- c("A", "a", "E", "e", "2", "6")

client_conn_data %>%
    filter(
        !substr(station_mac, 2, 2) %in% rand_prefixes
        )
```

#### 3. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее.

```{r}
client_data_processed <- client_conn_data %>%
    mutate(
        first_time_seen = as.POSIXct(first_time_seen),
        last_time_seen = as.POSIXct(last_time_seen),
        probed_essids = ifelse(is.na(probed_essids) | probed_essids == "", 
                            "Unknown", 
                            as.character(probed_essids))
    ) %>%
    filter(probed_essids != "Unknown")

requests <- client_data_processed %>%
    mutate(
        cluster = str_split(probed_essids, ",")
    ) %>%
    unnest(cluster) %>%
    mutate(
        cluster = str_trim(cluster),
        cluster = ifelse(cluster == "", "Unknown", cluster)
    ) %>%
    filter(cluster != "Unknown")

cl <- requests %>%
    group_by(station_mac, cluster) %>%
    summarise(
        first_appearance = min(first_time_seen, na.rm = TRUE),
        last_appearance = max(last_time_seen, na.rm = TRUE),
        duration_minutes = as.numeric(
        difftime(last_appearance, first_appearance, units = "mins")
        ),
        session_count = n(),
        avg_power = round(mean(power, na.rm = TRUE), 1),
        total_packets = sum(packets, na.rm = TRUE),
        packets_per_minute = ifelse(duration_minutes > 0,
                                round(total_packets / duration_minutes, 2),
                                0),
        .groups = "drop"
    ) %>%
    arrange(station_mac, first_appearance)

cl
```

#### 4. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер. 

```{r}
sustainability <- requests %>%
    group_by(cluster) %>%
    summarise(
        n_requests = n(),
        unique_devices = n_distinct(station_mac),
        mean_power = round(mean(power, na.rm = TRUE), 2),
        median_power = round(median(power, na.rm = TRUE), 2),
        sd_power = if (n() == 1) 0 else round(sd(power, na.rm = TRUE), 2),
        min_power = min(power, na.rm = TRUE),
        max_power = max(power, na.rm = TRUE),
        range_power = round(max_power - min_power, 2),
        cv_power = if (abs(mean_power) > 0) 
        round((sd_power / abs(mean_power)) * 100, 2) else 0,
        .groups = "drop"
    ) %>%
    filter(n_requests >= 5) %>%
    arrange(sd_power)

most_stable <- sustainability %>% slice_min(sd_power, n = 1)
most_stable
```

## Вывод

В данной работе мы научились анализировать логи Wi-Fi с использованием языка R